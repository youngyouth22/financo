import 'package:dartz/dartz.dart';
import 'package:financo/core/error/exceptions.dart';
import 'package:financo/core/error/failures.dart';
import 'package:financo/features/finance/data/datasources/finance_remote_datasource.dart';
import 'package:financo/features/finance/data/models/asset_model.dart';
import 'package:financo/features/finance/domain/entities/asset.dart';
import 'package:financo/features/finance/domain/entities/global_wealth.dart';
import 'package:financo/features/finance/domain/entities/wealth_snapshot.dart';
import 'package:financo/features/finance/domain/repositories/finance_repository.dart';

/// Implementation of FinanceRepository
///
/// Handles data operations and error mapping from data layer to domain layer.
class FinanceRepositoryImpl implements FinanceRepository {
  final FinanceRemoteDataSource remoteDataSource;

  FinanceRepositoryImpl({required this.remoteDataSource});

  @override
  Future<Either<Failure, List<Asset>>> getAssets() async {
    try {
      final assetModels = await remoteDataSource.getAssets();
      final assets = assetModels.map((model) => model.toEntity()).toList();
      return Right(assets);
    } on ServerException catch (e) {
      return Left(ServerFailure(message: e.message));
    } catch (e) {
      return Left(ServerFailure(message: 'Unexpected error: $e'));
    }
  }

  @override
  Future<Either<Failure, Asset>> getAssetById(String assetId) async {
    try {
      final assetModel = await remoteDataSource.getAssetById(assetId);
      return Right(assetModel.toEntity());
    } on ServerException catch (e) {
      return Left(ServerFailure(message: e.message));
    } catch (e) {
      return Left(ServerFailure(message: 'Unexpected error: $e'));
    }
  }

  @override
  Future<Either<Failure, Asset>> addAsset({
    required String name,
    required AssetType type,
    required AssetGroup assetGroup,
    required AssetProvider provider,
    required String assetAddressOrId,
    double initialBalance = 0.0,
  }) async {
    try {
      // Get current user ID from data source
      final userId = remoteDataSource.supabaseClient.auth.currentUser?.id;
      if (userId == null) {
        return const Left(
          ServerFailure(message: 'User not authenticated'),
        );
      }

      final now = DateTime.now();
      final assetModel = AssetModel(
        id: '', // Will be generated by Supabase
        userId: userId,
        name: name,
        type: type,
        assetGroup: assetGroup,
        provider: provider,
        balanceUsd: initialBalance,
        assetAddressOrId: assetAddressOrId.toLowerCase(),
        lastSync: now,
        createdAt: now,
        updatedAt: now,
      );

      final createdAsset = await remoteDataSource.addAsset(assetModel);

      // If it's a crypto asset, add to Moralis stream
      if (type == AssetType.crypto && provider == AssetProvider.moralis) {
        await remoteDataSource.addWalletToStream(assetAddressOrId);
      }

      return Right(createdAsset.toEntity());
    } on ServerException catch (e) {
      return Left(ServerFailure(message: e.message));
    } catch (e) {
      return Left(ServerFailure(message: 'Unexpected error: $e'));
    }
  }

  @override
  Future<Either<Failure, Asset>> updateAsset(Asset asset) async {
    try {
      final assetModel = AssetModel.fromEntity(asset);
      final updatedAsset = await remoteDataSource.updateAsset(assetModel);
      return Right(updatedAsset.toEntity());
    } on ServerException catch (e) {
      return Left(ServerFailure(message: e.message));
    } catch (e) {
      return Left(ServerFailure(message: 'Unexpected error: $e'));
    }
  }

  @override
  Future<Either<Failure, void>> deleteAsset(String assetId) async {
    try {
      // Get asset details before deletion
      final assetResult = await getAssetById(assetId);
      
      await remoteDataSource.deleteAsset(assetId);

      // If it's a crypto asset, remove from Moralis stream
      assetResult.fold(
        (failure) {}, // Asset not found, skip stream removal
        (asset) async {
          if (asset.type == AssetType.crypto &&
              asset.provider == AssetProvider.moralis) {
            await remoteDataSource.removeWalletFromStream(
              asset.assetAddressOrId,
            );
          }
        },
      );

      return const Right(null);
    } on ServerException catch (e) {
      return Left(ServerFailure(message: e.message));
    } catch (e) {
      return Left(ServerFailure(message: 'Unexpected error: $e'));
    }
  }

  @override
  Future<Either<Failure, GlobalWealth>> getGlobalWealth() async {
    try {
      final assetModels = await remoteDataSource.getAssets();
      final assets = assetModels.map((model) => model.toEntity()).toList();
      
      final globalWealth = GlobalWealth(
        assets: assets,
        lastUpdated: DateTime.now(),
      );

      return Right(globalWealth);
    } on ServerException catch (e) {
      return Left(ServerFailure(message: e.message));
    } catch (e) {
      return Left(ServerFailure(message: 'Unexpected error: $e'));
    }
  }

  @override
  Future<Either<Failure, List<WealthSnapshot>>> getWealthHistory({
    DateTime? startDate,
    DateTime? endDate,
    int? limit,
  }) async {
    try {
      final snapshotModels = await remoteDataSource.getWealthHistory(
        startDate: startDate,
        endDate: endDate,
        limit: limit,
      );
      
      final snapshots =
          snapshotModels.map((model) => model.toEntity()).toList();
      
      return Right(snapshots);
    } on ServerException catch (e) {
      return Left(ServerFailure(message: e.message));
    } catch (e) {
      return Left(ServerFailure(message: 'Unexpected error: $e'));
    }
  }

  @override
  Future<Either<Failure, double>> calculateNetWorth() async {
    try {
      final netWorth = await remoteDataSource.calculateNetWorth();
      return Right(netWorth);
    } on ServerException catch (e) {
      return Left(ServerFailure(message: e.message));
    } catch (e) {
      return Left(ServerFailure(message: 'Unexpected error: $e'));
    }
  }

  @override
  Future<Either<Failure, void>> recordWealthSnapshot() async {
    try {
      await remoteDataSource.recordWealthSnapshot();
      return const Right(null);
    } on ServerException catch (e) {
      return Left(ServerFailure(message: e.message));
    } catch (e) {
      return Left(ServerFailure(message: 'Unexpected error: $e'));
    }
  }

  @override
  Stream<Either<Failure, List<Asset>>> watchAssets() {
    try {
      return remoteDataSource.watchAssets().map(
        (assetModels) {
          final assets = assetModels.map((model) => model.toEntity()).toList();
          return Right<Failure, List<Asset>>(assets);
        },
      ).handleError((error) {
        if (error is ServerException) {
          return Left<Failure, List<Asset>>(
            ServerFailure(message: error.message),
          );
        }
        return Left<Failure, List<Asset>>(
          ServerFailure(message: 'Unexpected error: $error'),
        );
      });
    } catch (e) {
      return Stream.value(
        Left(ServerFailure(message: 'Failed to watch assets: $e')),
      );
    }
  }

  @override
  Future<Either<Failure, void>> addWalletToStream(String walletAddress) async {
    try {
      await remoteDataSource.addWalletToStream(walletAddress);
      return const Right(null);
    } on ServerException catch (e) {
      return Left(ServerFailure(message: e.message));
    } catch (e) {
      return Left(ServerFailure(message: 'Unexpected error: $e'));
    }
  }

  @override
  Future<Either<Failure, void>> removeWalletFromStream(
    String walletAddress,
  ) async {
    try {
      await remoteDataSource.removeWalletFromStream(walletAddress);
      return const Right(null);
    } on ServerException catch (e) {
      return Left(ServerFailure(message: e.message));
    } catch (e) {
      return Left(ServerFailure(message: 'Unexpected error: $e'));
    }
  }

  @override
  Future<Either<Failure, void>> setupMoralisStream() async {
    try {
      await remoteDataSource.setupMoralisStream();
      return const Right(null);
    } on ServerException catch (e) {
      return Left(ServerFailure(message: e.message));
    } catch (e) {
      return Left(ServerFailure(message: 'Unexpected error: $e'));
    }
  }

  @override
  Future<Either<Failure, void>> cleanupUserCryptoAssets() async {
    try {
      await remoteDataSource.cleanupUserCryptoAssets();
      return const Right(null);
    } on ServerException catch (e) {
      return Left(ServerFailure(message: e.message));
    } catch (e) {
      return Left(ServerFailure(message: 'Unexpected error: $e'));
    }
  }

  @override
  Future<Either<Failure, void>> syncAssets() async {
    try {
      // Trigger a manual sync by recording a wealth snapshot
      // This will recalculate net worth and update the history
      await remoteDataSource.recordWealthSnapshot();
      return const Right(null);
    } on ServerException catch (e) {
      return Left(ServerFailure(message: e.message));
    } catch (e) {
      return Left(ServerFailure(message: 'Unexpected error: $e'));
    }
  }
}
